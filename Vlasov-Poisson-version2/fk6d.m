function [fval] = fk6d(pde,Lev,Deg,TEND,quiet,compression)

%**************************************************************************
% This MATLAB-Interface for DG-SG Vlasov
% is an example to solve Vlasov Equations with Poisson Equations
% Vlasov Equation with Poisson solver:
% (1). f_t + v*grad_x f + E*grad_v f=0;
% (2). -Del (phi) = 1 - int_v f dv and E= (phi)'
% Major Changes:
% 1. Hash Table only contains Lev and Cell, but ignoring Deg
% 2. 2D Connectivity is constructed
% 3. A_encode is generated by looping the size of Hash table
% 4. Inverse HashTable contains the 1D index information
% 5. Set the value for using compressionVersion: IscompressionVersion = 1
% Note 1: the number of A_encode is much larger than the previous version
% Note 2: the ordering is different of previous version
%**************************************************************************
% clc
% clear
% close all
format short e

addpath(genpath(pwd))
%=============================================================
%% Step 1. Setting Parameters
% Lev: Level of the Mesh
%   Lev, LevX, and LevV
% Deg: Degree of Polynomial
% Dim: dimensionality
%   Dim, Dim_x, and Dim_v
% Lmax: x in [0,Lmax]
% Vmax: v in [-Vmax,Vmax]
% fval: initial condition for f
% rho: initial value of int_v fdv
% Maxwell coefficients: nu and eps
%=============================================================
% Test PDE and Ending Time

if ~exist('pde','var') || isempty(pde)
    % Equation setup
    pde = Vlasov4;
end
if ~exist('TEND','var') || isempty(TEND)
    % End time
    TEND = 1;
end
if ~exist('Lev','var') || isempty(Lev)
    % Number of levels
    Lev = 3;
end
if ~exist('Deg','var') || isempty(Deg)
    % Polynomial degree
    Deg = 2; % Deg = 2 Means Linear Element
end
if ~exist('quiet','var') || isempty(quiet)
    % Enable / disable print statements
    quiet = 0;
end
if ~exist('compression','var') || isempty(compression)
    % Use or not the compression reference version
    compression = 0;
end

Vmax = pde.Vmax;
Lmax = pde.Lmax;

% Level information
LevX = Lev;LevV = Lev;

% Dimensionality
Dim = 2;
DimX = 1;DimV = 1;

% Time step
dt = Lmax/2^LevX/Vmax/(2*Deg+1);

%*************************************************
%% Step 1.1. Set Up Matrices for Multi-wavelet
% Input:  Deg and Lev
% Output: Convert Matrix FMWT_COMP
%*************************************************
FMWT_COMP_x = OperatorTwoScale(Deg,2^LevX);
FMWT_COMP_v = OperatorTwoScale(Deg,2^LevV);

%*************************************************
%% Step 1.2. Initial Data according to Hash
% Generate the initial condition
% Input: LevX,LevV,Deg,Lmax,Vmax,pde
% Output: fval (fv and fx)--intial condition f(x,v,t=0)
%         rho--intial condition rho(x,t=0)
%*************************************************
if ~quiet; disp('[0] Setting up initial condition'); end
[fv,fx] = Intial_Con(LevX,LevV,Deg,Lmax,Vmax,pde,...
    FMWT_COMP_x,FMWT_COMP_v);

%=============================================================
%% Step 2. Generate Sparse Grids/Hash Table
% Input:    Lev-Level of the Mesh
%           Dim-dimensionality
% Output: HASH and HashInv
% Major Change: Ignoring the Deg from Hash Table
%   Assuming the uniform Deg for all components
%=============================================================
if ~quiet; disp('[1] Constructing hash and inverse hash tables'); end
[HASH,HASHInv] = HashTable(Lev,Dim);
HASHDOF = size(HASHInv,2);

% 2D connectivity
if ~quiet; disp('[2] Constructing connectivity table'); end
Con2D=Connect2D(Lev,HASH,HASHInv);

%*******************************************
% Generate the Initial Condition w.r.t Grids
%*******************************************
fval = sparse(Deg^Dim*HASHDOF,1);
if ~quiet; disp('[3] Calculate initial condition on the sparse-grid'); end
if compression == 3
    for i=1:HASH.dof
        ll=HASHInv{i};
        
        % 1D indices for (Lev1,Cell1)-->Index1,(Lev2,Cell2)-->Index2
        I1=ll(5);
        I2=ll(6);
        
        Index1 = Deg*(I1-1)+1:Deg*I1;
        Index2 = Deg*(I2-1)+1:Deg*I2;
        
        Index = Deg^Dim*(i-1)+1:Deg^Dim*i;
        
        fval = fval + sparse(Index,ones(size(Index,1),1),...
            kron(fv(Index1),fx(Index2)),...
            Deg^Dim*HASH.dof,1);
    end
else
    for i=1:HASH.dof
        ll=HASHInv{i};
        
        % 1D indices for (Lev1,Cell1)-->Index1,(Lev2,Cell2)-->Index2
        I1=ll(5);
        I2=ll(6);
        
        for k1 = 1:Deg
            
            Index1 = Deg*(I1-1)+k1;
            
            for k2 = 1:Deg
                
                Index2 = Deg*(I2-1)+k2;
                Index = Deg^2*(i-1)+Deg*(k1-1)+k2;
                
                fval = fval + sparse(Index,ones(size(Index,1),1),...
                    kron(fv(Index1),fx(Index2)),...
                    Deg^Dim*HASHDOF,1);
            end
        end
        
        
    end
end

clear fv fx


%=============================================================
%% Step 3. Generate time-independent coefficient matrices
% Vlasolv Solver:
%   Operators:
%               vMassV: int_v v*l_i(v)*l_j(v)dv
%               GradV: int_v (l_i(v))'*l_j(v)dv
%               GradX: int_x (m_i(x))'*m_j(x)dx
% Poisson Solver:
%               Operators: DelaX: int_x (m_i(x))''*m_j(x)dx
% Input:
%               LevX, LevV, k, dim, Lmax, Vmax
% Output:
%               2D Matrices--vMassV,GradV,GradX,DeltaX
%=============================================================
if ~quiet; disp('[4] Calculate time independent matrix coefficients'); end
[vMassV,GradV,GradX,DeltaX] = matrix_coeff_TI(LevX,LevV,Deg,Lmax,Vmax,...
    FMWT_COMP_x,FMWT_COMP_v);

if ~quiet; disp('[5] Generate A_encode data structure for time independent coefficients'); end
% Generate A_encode for Time-independent Matrix
if compression == 3
    A_encode=GlobalMatrixSG(vMassV,GradX,HASHInv,Con2D,Deg);
else
    %[A_encode,A_data]=GlobalMatrixSG_compressionVersion(vMassV,GradX,HASHInv,Con2D,Deg);
    
    % Generate the data required to construct A
    % This will be done only once per grid refinement, so can be done on
    % the host side.
    
    A_data = GlobalMatrixSG_SlowVersion(HASHInv,Con2D,Deg,compression);
    
end
%====================================================================
%% Step 4. Generate time-independent global Matrix
% Compute the global matrix for spacial variables "x" by
%
% Poisson Solver: A_Poisson (Hash, Dim_x,k,LevX,DeltaX)
%
% Input: Hash, Dim_x,k,LevX,DeltaX,or nu, eps, CurlCurlX
% Output: A_Poisson
% Another Idea is to solve Poisson Equation on the finest full grid
%====================================================================
if DimX>1
    % Construct DeltaX for DimX
else
    A_Poisson = DeltaX;
end

%=============================================================
%% Step 5. Time Loop
%	Step 5.1 Vlasov Equation
%       Generate time dependent coefficient matrix
%       Generate global matrix A_Vlasov(Hash,coef_mat,Dim)
%       Apply A_Vlasov->f by RK
%	Step 5.2 Poisson Equation
%       Solve Poisson Equation sol_Poisson by A_Poisson(f)
%       Compute E=(sol_Poisson)'
% Note:
% 3-rd order Runge-Kutta Methods
%   f1=f0+dt*(A*f0)
%   f2=3/4*f0+1/4*f1+1/4*dt*(A*f1)
%	f =1/3*f0+2/3*f2+2/3*dt*(A*f2)
% capability: vary the time-integration order of RK methods
%=============================================================
% At Time = 0
% Preparing the Plotting Data
% Plotting Data
if ~quiet; disp('[6] Plotting intial condition'); end

if ~quiet
    [Meval_v,v_node,Meval_x,x_node]=matrix_plot(LevX,LevV,Deg,Lmax,Vmax,...
        FMWT_COMP_x,FMWT_COMP_v);
    %---------------------
    % plot for validating
    %---------------------
    [xx,vv]=meshgrid(x_node,v_node);
    tmp=Multi_2D(Meval_v,Meval_x,fval,HASHInv,Lev,Deg);
    
    figure(1000)
    mesh(xx,vv,reshape(tmp,Deg*2^LevX,Deg*2^LevV)','FaceColor','interp','EdgeColor','interp');
    axis([0 Lmax -Vmax Vmax])
    view(0,90)
    colorbar
end


count=1;
plotFreq = 10;

if ~quiet; disp('[7] Advancing time ...'); end
for L = 1:floor(TEND/dt)
    
    timeStr = sprintf('Step %i of %i',L,floor(TEND/dt));
    if ~quiet; disp(timeStr); end
    
    %=============================================================
    %% Step 5.3. Generate time-dependent coefficient matrix
    % Vlasolv Solver:
    %   Operators:  EMassX: int_x E(x)*m_i(x)*m_j(x)dx
    % Input: Lev, Deg, Lmax, Vmax
    % Output: EMassX
    % Note: E is solved by Poisson or Maxwell's equation
    %=============================================================
    % Poisson Solver: Solve E from 1-rho=1-int f dv
    if ~quiet; disp('    [a] Solve poisson'); end
    E = PoissonSolve(LevX,Deg,Lmax,fval,A_Poisson,FMWT_COMP_x,Vmax);
    
    % Generate EMassX matrix
    if ~quiet; disp('    [b] Calculate time dependent matrix coeffs'); end
    EMassX = matrix_coeff_TD(LevX,Deg,Lmax,E,FMWT_COMP_x);
    
    % B_encode for Time-Dependent Matrices
    if ~quiet; disp('    [c] Generate A_encode for time-dependent coeffs'); end
    if compression == 3
        B_encode = GlobalMatrixSG(GradV,EMassX,HASHInv,Con2D,Deg);
        C_encode=[A_encode B_encode]; % This step is GlobalVlasov
    else

    end
    
    %====================================
    % RK Time Stepping Method
    %====================================
    if ~quiet; disp('    [d] RK3 time step'); end
    if compression == 3
        fval = TimeAdvance(C_encode,fval, dt,compression,Deg);
    else
        A_data{1}.vMassV    = vMassV;
        A_data{1}.GradX     = GradX;
        A_data{1}.GradV     = GradV;
        A_data{1}.EMassX    = EMassX;
        fval = TimeAdvance(A_data,fval, dt,compression,Deg);
    end
    
    time(count) = L*dt;
    count=count+1;
    
    
    if mod(L,plotFreq)==0 && ~quiet
        %---------------------
        % plot for validating
        %---------------------
        figure(1000)
        
        tmp=Multi_2D(Meval_v,Meval_x,fval,HASHInv,Lev,Deg);
        mesh(xx,vv,reshape(tmp,Deg*2^LevX,Deg*2^LevV)','FaceColor','interp','EdgeColor','interp');
        axis([0 Lmax -Vmax Vmax])
        view(0,90)
        colorbar
        
        title(['Time at ',num2str(L*dt)])
        pause (0.01)
    end
    
end

end

