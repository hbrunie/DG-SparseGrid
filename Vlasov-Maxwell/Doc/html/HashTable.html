<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="generator" content="MATLAB R2017b"><meta http-equiv="X-UA-Compatible" content="IE=edge,IE=9,chrome=1"><title>Algorithm 2--Sparse Grids (Algorithm for HashTable)</title><style type="text/css">
* {margin: 0; padding: 0;}
body {text-align: start; line-height: 17.234001159668px; min-height: 0px; white-space: normal; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-style: normal; font-size: 14px; font-weight: normal; text-decoration: none; white-space: normal; }
h1, h2 {font-weight: normal;}
.content { padding: 30px; }

.S0 { margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S1 { text-align: left; line-height: 26.3999996185303px; min-height: 24px; white-space: pre-wrap; color: rgb(213, 80, 0); font-family: Helvetica, Arial, sans-serif; font-size: 22px; white-space: pre-wrap; margin-left: 4px; margin-top: 3px; margin-bottom: 15px; margin-right: 10px;  }
.S2 { min-height: 0px; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S3 { text-align: left; line-height: 20.576000213623px; min-height: 20px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-size: 16px; font-weight: bold; white-space: pre-wrap; margin-left: 4px; margin-top: 3px; margin-bottom: 9px; margin-right: 10px;  }
.S4 { min-height: 0px; color: rgb(0, 95, 206); margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S5 { text-align: left; line-height: 20.576000213623px; min-height: 20px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-size: 16px; font-weight: bold; white-space: pre-wrap; margin-left: 4px; margin-top: 15px; margin-bottom: 9px; margin-right: 10px;  }
.S6 { text-align: left; line-height: 21px; min-height: 17px; white-space: pre-wrap; font-family: Helvetica, Arial, sans-serif; white-space: pre-wrap; margin-left: 4px; margin-top: 2px; margin-bottom: 9px; margin-right: 10px;  }
.S7 { font-weight: bold; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S8 { font-family: Helvetica, Arial, sans-serif; margin-left: 0px; margin-top: 10px; margin-bottom: 20px; margin-right: 0px;  }
.S9 { text-align: left; line-height: 21px; white-space: pre-wrap; white-space: pre-wrap; margin-left: 56px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S10 { text-decoration: underline; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S11 { margin-left: 3px; margin-top: 10px; margin-bottom: 4px; margin-right: 3px;  }
.S12 { min-height: 18px; white-space: nowrap; white-space: nowrap; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S13 { min-height: 0px; white-space: pre; white-space: pre; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 45px;  }
.S14 { color: rgb(34, 139, 34); margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S15 { color: rgb(160, 32, 240); margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S16 { color: rgb(0, 0, 255); margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S17 { font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-weight: bold; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S18 { font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }

.CodeBlock {margin: 10px 0 10px 0; background-color: #F7F7F7;}
.CodeBlock+.paragraphNode {margin-top: 10px;}
.lineNode {padding-left: 10px; border-left: 1px solid #E9E9E9; border-right: 1px solid #E9E9E9;}
.inlineWrapper:first-child .lineNode,.inlineWrapper.outputs+.inlineWrapper .lineNode {padding-top: 5px; border-top: 1px solid #E9E9E9;}
.inlineWrapper:last-child .lineNode,.inlineWrapper.outputs .lineNode {padding-bottom: 5px; border-bottom: 1px solid #E9E9E9;}
.lineNode .textBox {white-space: pre;}
</style></head><body><div class = "content"><div class = 'SectionBlock containment'><h1 class = "S1"><span class = "S2"><span class="S0">Algorithm 2--Sparse Grids (Algorithm for HashTable)</span></span></h1></div><div class = "S0"></div><div class = 'SectionBlock containment'><h2 class = "S3"><a href = "file:///Users/lmm/Documents/code-ornl/DG-SparseGrid/Vlasov-Maxwell/HashTable.m"><span class = "S0"><span class="S0">CODE</span></span></a><span class = "S2"><span class="S0"> </span></span></h2><h2 class = "S5"><span class = "S2"><span class="S0">[forwardHash,inverseHash] = HashTable(maxLev,Dim)</span></span></h2></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S6"><span class = "S2"><span class="S7">INPUT: </span></span></div><ul class = "S8"><li class = "S9"><span class = "S0"><span class="S0">maxLev--Max Level Information for Computing</span></span></li><li class = "S9"><span class = "S0"><span class="S0">Dim--Dimensionality for DimX+DimV</span></span></li></ul><div class = "S6"><span class = "S2"><span class="S7">OUTPUT: </span></span></div><ul class = "S8"><li class = "S9"><span class = "S0"><span class="S0">forwardHash -- Hash Table</span></span></li><li class = "S9"><span class = "S0"><span class="S0">inverseHash -- look up mapping for Hash table</span></span></li></ul><div class = "S6"><span class = "S2"><span class="S10">Algorithm</span></span><span class = "S2"><span class="S0">: Require </span></span></div><div class = "S6"><span class = "S2"><span class="S0">                Lev(1)+Lev(2)+....+Lev(Dim)&lt;=maxLev</span></span></div><div class = "S6"><span class = "S2"><span class="S0">                Cell(i) is 0~2^(Lev(i)-1)-1 or 0, for i=1,...,Dim</span></span></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S6"><span class = "S2"><span class="S0">STEP 1. Find all the possible Dim numbers from maxLev</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S14">% All combinations from choosing Dim numbers from vector [0:maxLev]</span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">combs = permn(0:maxLev, Dim);</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment active'><div class = "S6"><span class = "S2"><span class="S0">STEP 2. For each Level information, find the possible cell information, and then construct up forward and inverse HashTable</span></span></div><div class = 'CodeBlock contiguous'><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0"></span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S14">% Find all Cells correspondin</span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">g </span><span class="S15">to the related Lev(1:Dim)</span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">key = zeros(1,2*Dim);</span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">count = 1;</span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S16">for </span><span class="S0">i = 1:size(combs,1)</span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">    </span><span class="S16">if </span><span class="S0">sum(combs(i,:))&lt;=Lev</span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">        nLev = combs(i,:);</span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">        nCell = AllCell(nLev);</span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">        nz = size(nCell,1);</span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">        </span><span class="S16">for </span><span class="S0">ii = 1:nz</span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">            key(1:Dim) = nLev;</span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">            key(Dim+1:end) = nCell(ii,:);</span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">            forwardHash.(sprintf(</span><span class="S15">'i%g_'</span><span class="S0">,key))=count;</span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">            </span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">            index_dim = LevCell2index(nLev,nCell(ii,:));</span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">            </span><span class="S0">inverseHash</span><span class="S0">{count} = [key,index_dim];</span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">               </span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">            count=count+1;</span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">        </span><span class="S16">end</span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">        </span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">        </span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S0">    </span><span class="S16">end</span></span></div></div><div class = 'inlineWrapper'><div class = "S12 lineNode"><span class = "S13"><span class="S16">end</span></span></div></div></div></div><div class = "S0"></div><div class = 'SectionBlock containment'><div class = "S6"><span class = "S2"><span class="S17">For Example:</span></span></div><div class = "S6"><span class = "S2"><span class="S18">[forwardHash,inverseHash] = HashTable(1,3); will generate</span></span></div><div class = "S6"><span class = "S2"><span class="S18">forwardHash :: struct with fields:</span></span></div><div class = "S6"><span class = "S2"><span class="S18">    i0_i0_i0_i0_i0_i0_: 1</span></span></div><div class = "S6"><span class = "S2"><span class="S18">    i0_i0_i1_i0_i0_i0_: 2</span></span></div><div class = "S6"><span class = "S2"><span class="S18">    i0_i1_i0_i0_i0_i0_: 3</span></span></div><div class = "S6"><span class = "S2"><span class="S18">    i1_i0_i0_i0_i0_i0_: 4</span></span></div><div class = "S6"><span class = "S2"><span class="S18">inverseHash :: 1×4 cell array  %(Lev1,Lev2,Lev3,Cell1,Cell2,Cell3,Index1,Index2,Index3)</span></span></div><div class = "S6"><span class = "S2"><span class="S18">[0,0,0,0,0,0,1,1,1]	</span></span></div><div class = "S6"><span class = "S2"><span class="S18">[0,0,1,0,0,0,1,1,2]	</span></span></div><div class = "S6"><span class = "S2"><span class="S18">[0,1,0,0,0,0,1,2,1]	</span></span></div><div class = "S6"><span class = "S2"><span class="S18">[1,0,0,0,0,0,2,1,1]</span></span></div></div></div>
<!-- 
##### SOURCE BEGIN #####
%% Algorithm 2REPLACE_WITH_DASH_DASHSparse Grids (Algorithm for HashTable)
%% <file:///Users/lmm/Documents/code-ornl/DG-SparseGrid/Vlasov-Maxwell/HashTable.m CODE> 
%% [forwardHash,inverseHash] = HashTable(maxLev,Dim)
% *INPUT: *
% 
% * maxLevREPLACE_WITH_DASH_DASHMax Level Information for Computing
% * DimREPLACE_WITH_DASH_DASHDimensionality for DimX+DimV
% 
% *OUTPUT: *
% 
% * forwardHash REPLACE_WITH_DASH_DASH Hash Table
% * inverseHash REPLACE_WITH_DASH_DASH look up mapping for Hash table
% 
% Algorithm: Require 
% 
%                 Lev(1)+Lev(2)+....+Lev(Dim)<=maxLev
% 
%                 Cell(i) is 0~2^(Lev(i)-1)-1 or 0, for i=1,...,Dim
% 
% STEP 1. Find all the possible Dim numbers from maxLev
%%
% All combinations from choosing Dim numbers from vector [0:maxLev]
combs = permn(0:maxLev, Dim);
%% 
% STEP 2. For each Level information, find the possible cell information, 
% and then construct up forward and inverse HashTable
%%

% Find all Cells correspondin
g to the related Lev(1:Dim)
key = zeros(1,2*Dim);
count = 1;
for i = 1:size(combs,1)
    if sum(combs(i,:))<=Lev
        nLev = combs(i,:);
        nCell = AllCell(nLev);
        nz = size(nCell,1);
        for ii = 1:nz
            key(1:Dim) = nLev;
            key(Dim+1:end) = nCell(ii,:);
            forwardHash.(sprintf('i%g_',key))=count;
            
            index_dim = LevCell2index(nLev,nCell(ii,:));
            inverseHash{count} = [key,index_dim];
               
            count=count+1;
        end
        
        
    end
end
%% 
% |*For Example:*|
% 
% |[forwardHash,inverseHash] = HashTable(1,3); will generate|
% 
% |forwardHash :: struct with fields:|
% 
% |    i0_i0_i0_i0_i0_i0_: 1|
% 
% |    i0_i0_i1_i0_i0_i0_: 2|
% 
% |    i0_i1_i0_i0_i0_i0_: 3|
% 
% |    i1_i0_i0_i0_i0_i0_: 4|
% 
% |inverseHash :: 1×4 cell array  %(Lev1,Lev2,Lev3,Cell1,Cell2,Cell3,Index1,Index2,Index3)|
% 
% |[0,0,0,0,0,0,1,1,1]	|
% 
% |[0,0,1,0,0,0,1,1,2]	|
% 
% |[0,1,0,0,0,0,1,2,1]	|
% 
% |[1,0,0,0,0,0,2,1,1]|
##### SOURCE END #####
--></body></html>